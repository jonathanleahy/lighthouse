package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48-dev

import (
	"context"
	"encoding/json"

	"github.com/pismo/console-audit-bff/internal/app/adapter/web/graphql/entity"
	"github.com/pismo/console-audit-bff/internal/app/adapter/web/graphql/generated"
)

// CreateRole is the resolver for the create_role field.
func (r *mutationResolver) CreateRole(ctx context.Context, role entity.RoleInput) (string, error) {
	err := r.Manager.AuditService.CreateRole(ctx, &role)
	if err != nil {
		if err.Error() == "Duplicated role" {
			return err.Error(), nil
		}
		return "Failed to create role", err
	}

	return "Role created successfully", nil
}

// CreateFeature is the resolver for the create_feature field.
func (r *mutationResolver) CreateFeature(ctx context.Context, feature entity.FeatureInput, user *string, actions []entity.AuditAction, domains []string, domainID *string, cid *string) (string, error) {
	err := r.Manager.AuditService.CreateFeature(ctx, &feature, user, actions, domains, domainID, cid)
	if err != nil {
		if err.Error() == "Duplicated feature" {
			return err.Error(), nil
		}
		return "Failed to create feature", err
	}

	return "Feature created successfully", nil
}

// UpdateFeature is the resolver for the update_feature field.
func (r *mutationResolver) UpdateFeature(ctx context.Context, feature entity.FeatureInput, id int, user *string, actions []entity.AuditAction, domains []string, domainID *string, cid *string) (string, error) {
	err := r.Manager.AuditService.UpdateFeature(ctx, &feature, id, user, actions, domains, domainID, cid)
	if err != nil {
		if err.Error() == "Duplicated feature" {
			return err.Error(), nil
		}
		return "Failed to update feature", err
	}

	return "Feature updated successfully", nil
}

// DeleteFeature is the resolver for the delete_feature field.
func (r *mutationResolver) DeleteFeature(ctx context.Context, id int, user *string, actions []entity.AuditAction, domains []string, domainID *string, cid *string) (string, error) {
	err := r.Manager.AuditService.DeleteFeature(ctx, id)
	if err != nil {
		return "Failed to delete feature", err
	}

	return "Feature deleted successfully", nil
}

// CreateEndpoint is the resolver for the create_endpoint field.
func (r *mutationResolver) CreateEndpoint(ctx context.Context, endpoint entity.EndpointInput, user *string, actions []entity.AuditAction, domains []string, domainID *string, cid *string) (string, error) {
	err := r.Manager.AuditService.CreateEndpoint(ctx, &endpoint, user, actions, domains, domainID, cid)
	if err != nil {
		if err.Error() == "Duplicated endpoint" {
			return err.Error(), nil
		}
		return "Failed to create endpoint", err
	}

	return "Endpoint created successfully", nil
}

// UpdateEndpoint is the resolver for the update_endpoint field.
func (r *mutationResolver) UpdateEndpoint(ctx context.Context, endpoint entity.EndpointInput, id int, user *string, actions []entity.AuditAction, domains []string, domainID *string, cid *string) (string, error) {
	err := r.Manager.AuditService.UpdateEndpoint(ctx, &endpoint, id, user, actions, domains, domainID, cid)
	if err != nil {
		if err.Error() == "Duplicated endpoint" {
			return err.Error(), nil
		}
		return "Failed to update endpoint", err
	}

	return "Endpoint updated successfully", nil
}

// DeleteEndpoint is the resolver for the delete_endpoint field.
func (r *mutationResolver) DeleteEndpoint(ctx context.Context, id int, user *string, actions []entity.AuditAction, domains []string, domainID *string, cid *string) (string, error) {
	err := r.Manager.AuditService.DeleteEndpoint(ctx, id)
	if err != nil {
		return "Failed to delete endpoint", err
	}

	return "Endpoint deleted successfully", nil
}

// UpdateRole is the resolver for the update_role field.
func (r *mutationResolver) UpdateRole(ctx context.Context, role entity.RoleInput) (string, error) {
	err := r.Manager.AuditService.UpdateRole(ctx, &role)
	if err != nil {
		if err.Error() == "Duplicated role" {
			return err.Error(), nil
		}
		return "Failed to update role", err
	}

	return "Role updated successfully", nil
}

// DeleteRole is the resolver for the delete_role field.
func (r *mutationResolver) DeleteRole(ctx context.Context, id int) (string, error) {
	err := r.Manager.AuditService.DeleteRole(ctx, id)
	if err != nil {
		return "Failed to delete role", err
	}

	return "Role deleted successfully", nil
}

// AttachRoleToUser is the resolver for the attach_role_to_user field.
func (r *mutationResolver) AttachRoleToUser(ctx context.Context, id int, email string) (string, error) {
	err := r.Manager.AuditService.AttachRoleToUser(ctx, id, email)
	if err != nil {
		return "Failed to attach user to role", err
	}

	return "Role attached successfully", nil
}

// DetachRoleToUser is the resolver for the detach_role_to_user field.
func (r *mutationResolver) DetachRoleToUser(ctx context.Context, id int, email string) (string, error) {
	err := r.Manager.AuditService.DetachRoleToUser(ctx, id, email)
	if err != nil {
		return "Failed to detach user to role", err
	}

	return "Role detached successfully", nil
}

// AttachRoleToFeature is the resolver for the attach_role_to_feature field.
func (r *mutationResolver) AttachRoleToFeature(ctx context.Context, id int, featureID int, permission entity.ActionInput) (string, error) {
	err := r.Manager.AuditService.AttachRoleToFeature(ctx, id, featureID, permission)
	if err != nil {
		return "Failed to attach feature to role", err
	}

	return "Feature attached successfully", nil
}

// DetachRoleToFeature is the resolver for the detach_role_to_feature field.
func (r *mutationResolver) DetachRoleToFeature(ctx context.Context, id int, featureID int, permission entity.ActionInput) (string, error) {
	err := r.Manager.AuditService.DetachRoleToFeature(ctx, id, featureID, permission)
	if err != nil {
		return "Failed to detach feature to role", err
	}

	return "Feature detached successfully", nil
}

// FindAuditByID is the resolver for the find_audit_by_id field.
func (r *queryResolver) FindAuditByID(ctx context.Context, id int) (*entity.Audit, error) {
	response, err := r.Manager.AuditService.FindAuditByID(ctx, id)
	if err != nil || response == nil {
		return nil, err
	}

	output := &entity.Audit{
		ID: int(response.ID),
	}

	if response.Operation != nil {
		output.Operation = &entity.Operation{
			Tenant:   response.Operation.Tenant,
			Action:   response.Operation.Action,
			Domain:   response.Operation.Domain,
			DomainID: response.Operation.DomainID,
			Origin:   response.Operation.Origin,
			Cid:      response.Operation.CID,
			Date:     response.Operation.Date,
		}
	}

	if response.User != nil {
		output.User = &entity.User{
			Email: response.User.Email,
			Roles: response.User.Roles,
		}
	}

	if response.UserAgent != nil {
		output.UserAgent = &entity.UserAgent{
			Device:   response.UserAgent.Device,
			DeviceIP: response.UserAgent.DeviceIp,
		}
	}

	if response.Localization != nil {
		output.Localization = &entity.Localization{
			Latitude:  response.Localization.Latitude,
			Longitude: response.Localization.Longitude,
		}
	}

	if response.Http != nil {
		output.HTTP = &entity.HTTP{
			Code:     response.Http.Code,
			Request:  response.Http.Request,
			Response: response.Http.Response,
		}
	}

	return output, nil
}

// SearchAudit is the resolver for the search_audit field.
func (r *queryResolver) SearchAudit(ctx context.Context, page *int, perPage *int, order *entity.Order, beginDate *string, endDate *string, user *string, actions []entity.AuditAction, domains []string, domainID *string, cid *string) (*entity.SearchAudit, error) {
	if page == nil {
		page = new(int)
		*page = 1
	}

	if perPage == nil {
		perPage = new(int)
		*perPage = 10
	}

	if order == nil {
		order = new(entity.Order)
		*order = entity.OrderDesc
	}

	response, err := r.Manager.AuditService.SearchAudit(ctx, page, perPage, order, beginDate, endDate, user, actions, domains, domainID, cid)
	if err != nil {
		return nil, err
	}

	audits := make([]*entity.Audit, len(response.Items), len(response.Items))
	for i, item := range response.Items {
		audits[i] = &entity.Audit{
			ID: int(item.ID),
		}

		if item.Operation != nil {
			audits[i].Operation = &entity.Operation{
				Tenant:   item.Operation.Tenant,
				Action:   item.Operation.Action,
				Domain:   item.Operation.Domain,
				DomainID: item.Operation.DomainID,
				Origin:   item.Operation.Origin,
				Cid:      item.Operation.CID,
				Date:     item.Operation.Date,
			}
		}

		if item.User != nil {
			audits[i].User = &entity.User{
				Email: item.User.Email,
				Roles: item.User.Roles,
			}
		}

		if item.UserAgent != nil {
			audits[i].UserAgent = &entity.UserAgent{
				Device:   item.UserAgent.Device,
				DeviceIP: item.UserAgent.DeviceIp,
			}
		}

		if item.Localization != nil {
			audits[i].Localization = &entity.Localization{
				Latitude:  item.Localization.Latitude,
				Longitude: item.Localization.Longitude,
			}
		}

		if item.Http != nil {
			audits[i].HTTP = &entity.HTTP{
				Code:     item.Http.Code,
				Request:  item.Http.Request,
				Response: item.Http.Response,
			}
		}
	}

	return &entity.SearchAudit{
		CurrentPage: response.CurrentPage,
		Pages:       response.Pages,
		PerPage:     response.PerPage,
		TotalItems:  response.TotalItems,
		Audits:      audits,
	}, nil
}

// ListRoles is the resolver for the list_roles field.
func (r *queryResolver) ListRoles(ctx context.Context) ([]*entity.Role, error) {
	roles, err := r.Manager.AuditService.ListRoles(ctx)
	if err != nil || roles == nil {
		return nil, err
	}
	return roles, nil
}

// ListUserRoles is the resolver for the list_user_roles field.
func (r *queryResolver) ListUserRoles(ctx context.Context, user *string, actions []entity.AuditAction, domains []string, domainID *string, cid *string) (*entity.ListUserRoles, error) {
	roles, err := r.Manager.AuditService.ListUserRoles(ctx, user, actions, domains, domainID, cid)
	if err != nil || roles.Roles == nil {
		return nil, err
	}

	output := &entity.ListUserRoles{Roles: make([]string, 0)}

	output.Roles = append(output.Roles, roles.Roles...)

	return output, nil
}

// SearchRoles is the resolver for the search_roles field.
func (r *queryResolver) SearchRoles(ctx context.Context, email *string, feature *string) (*entity.ListRoles, error) {
	roles, err := r.Manager.AuditService.SearchRoles(ctx, email, feature)
	if err != nil || roles == nil {
		return nil, err
	}

	rolesSerialized, _ := json.Marshal(roles)

	response := string(rolesSerialized)
	return &entity.ListRoles{Data: &response}, nil
}

// SearchFeature is the resolver for the search_feature field.
func (r *queryResolver) SearchFeature(ctx context.Context, page *int, perPage *int, order *entity.Order, id *string, name *string, parentFeatureID *string, user *string, actions []entity.AuditAction, domains []string, domainID *string, cid *string) (*entity.SearchFeature, error) {
	if page == nil {
		page = new(int)
		*page = 1
	}

	if perPage == nil {
		perPage = new(int)
		*perPage = 10
	}

	if order == nil {
		order = new(entity.Order)
		*order = entity.OrderDesc
	}

	response, err := r.Manager.AuditService.SearchFeature(ctx, page, perPage, order, id, name, parentFeatureID, user, actions, domains, domainID, cid)
	if err != nil {
		return nil, err
	}

	features := make([]*entity.Feature, len(response.Items), len(response.Items))
	for i, item := range response.Items {
		features[i] = &entity.Feature{
			ID:              int(item.ID),
			Name:            item.Name,
			ParentFeatureID: item.ParentFeatureID,
		}

	}

	return &entity.SearchFeature{
		CurrentPage: response.CurrentPage,
		Pages:       response.Pages,
		PerPage:     response.PerPage,
		TotalItems:  response.TotalItems,
		Features:    features,
	}, nil
}

// FindFeatureByID is the resolver for the find_feature_by_id field.
func (r *queryResolver) FindFeatureByID(ctx context.Context, id int) (*entity.Feature, error) {
	response, err := r.Manager.AuditService.FindFeatureByID(ctx, id)
	if err != nil || response == nil {
		return nil, err
	}

	return response, nil
}

// SearchEndpoint is the resolver for the search_endpoint field.
func (r *queryResolver) SearchEndpoint(ctx context.Context, page *int, perPage *int, order *entity.Order, id *string, serviceName *string, method *string, path *string, user *string, actions []entity.AuditAction, domains []string, domainID *string, cid *string) (*entity.SearchEndpoint, error) {
	if page == nil {
		page = new(int)
		*page = 1
	}

	if perPage == nil {
		perPage = new(int)
		*perPage = 10
	}

	if order == nil {
		order = new(entity.Order)
		*order = entity.OrderDesc
	}

	response, err := r.Manager.AuditService.SearchEndpoint(ctx, page, perPage, order, id, serviceName, method, path, user, actions, domains, domainID, cid)
	if err != nil {
		return nil, err
	}

	Endpoints := make([]*entity.Endpoint, len(response.Items), len(response.Items))
	for i, item := range response.Items {
		Endpoints[i] = &entity.Endpoint{
			ID:          int(item.ID),
			ServiceName: item.ServiceName,
			Method:      item.Method,
			Path:        item.Path,
		}

	}

	return &entity.SearchEndpoint{
		CurrentPage: response.CurrentPage,
		Pages:       response.Pages,
		PerPage:     response.PerPage,
		TotalItems:  response.TotalItems,
		Endpoints:   Endpoints,
	}, nil
}

// FindEndpointByID is the resolver for the find_endpoint_by_id field.
func (r *queryResolver) FindEndpointByID(ctx context.Context, id int) (*entity.Endpoint, error) {
	response, err := r.Manager.AuditService.FindEndpointByID(ctx, id)
	if err != nil || response == nil {
		return nil, err
	}

	return response, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

